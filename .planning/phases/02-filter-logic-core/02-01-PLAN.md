---
phase: 02-filter-logic-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/views/Playlist.vue
  - src/components/PlaylistFilterDropdown.vue
autonomous: true

must_haves:
  truths:
    - "Filter dropdown displays actual marks extracted from current playlist's tracks"
    - "Each mark shows a badge count indicating how many tracks have that mark"
    - "When user selects marks, track list updates to show only matching tracks"
    - "When no marks selected, all tracks are shown (default state)"
    - "Filter state clears automatically when switching to a different playlist"
  artifacts:
    - path: "src/views/Playlist.vue"
      provides: "Mark extraction logic, badge count computation, filtered track list"
      min_lines: 380
    - path: "src/components/PlaylistFilterDropdown.vue"
      provides: "Badge display in dropdown items"
      min_lines: 150
  key_links:
    - from: "src/views/Playlist.vue"
      to: "useMusicStore.musicsGroupedByCover"
      via: "computed property accessing store"
      pattern: "musicsGroupedByCover\\.value"
    - from: "src/views/Playlist.vue"
      to: "PlaylistFilterDropdown marks prop"
      via: "availableMarks computed property"
      pattern: ":marks=\"availableMarks\""
    - from: "src/views/Playlist.vue"
      to: "UiVerticalList items prop"
      via: "filteredTracks computed property"
      pattern: ":items"
---

<objective>
Implement reactive mark extraction and OR-logic filtering for playlist tracks.

Purpose: Enable users to filter playlist tracks by selecting marks, seeing only tracks that match any selected mark (OR logic). Marks are extracted from current playlist's tracks with badge counts, and filters clear automatically when switching playlists.

Output: Working filter logic with mark extraction, badge counts, reactive filtering, and lifecycle management.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-filter-ui-foundation/01-01-SUMMARY.md
@.planning/phases/02-filter-logic-core/02-CONTEXT.md
@.planning/phases/02-filter-logic-core/02-RESEARCH.md
@src/views/Playlist.vue
@src/components/PlaylistFilterDropdown.vue
@src/composables/useMusicStore.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement mark extraction and filtering logic in Playlist.vue</name>
  <files>src/views/Playlist.vue</files>
  <action>
Replace mock marks data with real mark extraction and filtering logic:

1. **Replace filter state structure:**
   - Change `selectedMarks` from `ref<string[]>` to `ref<Set<string>>`
   - Create `selectedMarksArray` computed property with get/set to transform Set ↔ Array for v-model binding

2. **Extract marks from current playlist:**
   - Create `availableMarks` computed property that:
     - Gets current playlist via `getPlaylist(props.playlistId)`
     - Creates Set of track IDs from `playlist.list`
     - Iterates through `musicsGroupedByCover.value` (Map<string, MusicData[]>)
     - For each mark, checks if any tracks in that mark group exist in current playlist using `tracks.some(t => playlistTrackIds.has(t.id))`
     - Returns array of marks that have tracks in current playlist
     - Preserves Map iteration order (first appearance order)

3. **Calculate badge counts:**
   - Create `markBadgeCounts` computed property that:
     - Gets current playlist track IDs as Set
     - Iterates through `musicsGroupedByCover.value`
     - Counts tracks per mark using `tracks.filter(t => playlistTrackIds.has(t.id)).length`
     - Returns `Map<string, number>` with mark → count mapping
     - Only includes marks with count > 0

4. **Implement OR-logic filtering:**
   - Modify existing `items` computed property (used by useDragAndSort) to use filtered track list
   - Create `filteredTracks` computed property that:
     - Gets all tracks from current playlist: `playlist.list.map(id => getMusicData(id)).filter((t): t is MusicData => t != null)`
     - If `selectedMarks.value.size === 0`, return all tracks (default state)
     - Otherwise, filter tracks using `tracks.filter(track => selectedMarks.value.has(track.data.mark))`
     - Use Set.has() for O(1) lookup performance
   - Update `items` computed to use `filteredTracks` instead of direct playlist.list mapping

5. **Add playlist change watcher:**
   - Add `watch(() => props.playlistId, () => selectedMarks.value.clear())`
   - This auto-clears filter when user switches playlists
   - Component unmount naturally clears local state

**Important:** Use existing store methods (`getMusicData`, `getPlaylist`) and store computed properties (`musicsGroupedByCover`). Do NOT modify store implementation.

**Edge cases:**
- Empty/null marks: Exclude from mark list (they indicate data issues)
- Playlist not found: Return empty arrays
- No matching tracks after filtering: Display empty list (UI shows "no tracks")
  </action>
  <verify>
1. Dev server running: `pnpm dev`
2. Check browser console for no errors
3. Inspect Vue DevTools:
   - `availableMarks` computed shows array of marks from current playlist
   - `markBadgeCounts` computed shows Map with mark counts
   - `selectedMarks` ref is Set<string>
   - `filteredTracks` computed updates when marks selected
  </verify>
  <done>
- `availableMarks` computed property extracts marks from current playlist tracks
- `markBadgeCounts` computed property calculates track counts per mark
- `filteredTracks` computed property filters tracks using OR logic with Set.has()
- `selectedMarks` state uses Set internally, transforms to Array for v-model
- Watch on playlistId clears filter state on playlist change
- All tracks shown when no marks selected
  </done>
</task>

<task type="auto">
  <name>Task 2: Add badge display to PlaylistFilterDropdown component</name>
  <files>src/components/PlaylistFilterDropdown.vue</files>
  <action>
Add badge count display to each mark in the dropdown:

1. **Add markCounts prop:**
   - Add to defineProps: `markCounts?: Map<string, number>`
   - Make it optional with default empty Map

2. **Update dropdown item template:**
   - In the DropdownMenuCheckboxItem loop, add badge display after mark name
   - Badge structure:
     ```vue
     <span
       v-if="markCounts?.has(mark)"
       :class="pika({
         fontSize: '12px',
         color: 'var(--color-secondary-text)',
         marginLeft: 'auto',
         fontWeight: '500'
       })"
     >
       {{ markCounts.get(mark) }}
     </span>
     ```
   - Position badge using `marginLeft: 'auto'` to push it to the right
   - Only show badge if count exists in map

3. **Update empty state handling:**
   - Empty state should show when `marks.length === 0` (already implemented)
   - No changes needed for empty state

**Styling:**
- Badge uses secondary text color
- Font size 12px (smaller than mark name)
- Font weight 500 (semi-bold) for visibility
- Right-aligned using flexbox

**Do NOT:**
- Add click handlers to badge (it's display-only)
- Recalculate badge counts on filter change (passed from parent as static values)
  </action>
  <verify>
1. Component file updated with markCounts prop and badge display
2. No TypeScript errors: `pnpm type-check`
3. Visual inspection in browser:
   - Each mark shows badge count on the right
   - Badge uses correct styling (smaller, semi-bold, secondary color)
   - Badge only appears for marks with counts
  </verify>
  <done>
- PlaylistFilterDropdown accepts markCounts prop (Map<string, number>)
- Each dropdown item displays badge count to the right of mark name
- Badge styling matches design (12px, secondary color, semi-bold)
- Badge only shows when count exists in map
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire mark counts to dropdown and verify filtering</name>
  <files>src/views/Playlist.vue</files>
  <action>
Connect computed properties to PlaylistFilterDropdown component:

1. **Update PlaylistFilterDropdown binding in template:**
   - Change `:marks="marks"` to `:marks="availableMarks"`
   - Change `v-model="selectedMarks"` to `v-model="selectedMarksArray"`
   - Add `:mark-counts="markBadgeCounts"` prop
   - Result:
     ```vue
     <PlaylistFilterDropdown
       v-model="selectedMarksArray"
       :marks="availableMarks"
       :mark-counts="markBadgeCounts"
     />
     ```

2. **Remove mock data:**
   - Delete the line `const marks = ref(['Mark A', 'Mark B', 'Mark C'])`

3. **Verify prop naming:**
   - Component expects `markCounts` (camelCase)
   - Template uses `:mark-counts` (kebab-case) per Vue convention
   - Vue automatically transforms kebab-case to camelCase

**Final state:**
- Filter dropdown receives real marks from current playlist
- Badge counts display based on track counts in current playlist
- Selecting marks filters the track list reactively
- Switching playlists clears filter and updates marks/counts
  </action>
  <verify>
1. Full integration test in browser:
   - Open a playlist with multiple marks
   - Dropdown shows marks from that playlist with badge counts
   - Select marks → track list filters to show only matching tracks
   - Select multiple marks → tracks matching ANY selected mark shown (OR logic)
   - Clear all → all tracks shown again
   - Navigate to different playlist → filter clears, new marks shown
2. Test empty state:
   - Navigate to empty playlist or playlist with no marks
   - Dropdown shows "No marks available"
3. Test filtered empty state:
   - Select marks that match some tracks
   - Verify count matches badge number
4. Console check: No errors or warnings
  </verify>
  <done>
- PlaylistFilterDropdown receives availableMarks, selectedMarksArray, and markBadgeCounts from Playlist.vue
- Mock marks data removed
- Dropdown displays real marks with accurate badge counts
- Track list filters reactively based on selected marks using OR logic
- Filter state clears when switching playlists
- All edge cases handled (empty playlist, no marks, no matching tracks)
  </done>
</task>

</tasks>

<verification>
## Functional Verification

**Manual testing checklist:**
1. ✓ Open playlist → see marks from that playlist in dropdown
2. ✓ Each mark shows badge count matching number of tracks with that mark
3. ✓ Select one mark → track list shows only tracks with that mark
4. ✓ Select multiple marks → track list shows tracks matching ANY selected mark (OR logic)
5. ✓ Badge counts remain static while filtering (don't change when marks selected)
6. ✓ Clear all → all tracks shown again
7. ✓ Switch to different playlist → filter clears, new marks displayed
8. ✓ Empty playlist or no marks → "No marks available" message shown
9. ✓ Select marks that match zero tracks → empty track list (no crash)

**Code verification:**
- `availableMarks` extracts marks from `musicsGroupedByCover` filtered to current playlist
- `markBadgeCounts` calculates correct counts from current playlist tracks
- `filteredTracks` uses Set.has() for O(1) mark checking (not array.includes)
- `selectedMarks.value.size === 0` check ensures default state shows all tracks
- Watch on `props.playlistId` clears filter state
- PlaylistFilterDropdown displays badges correctly

**Performance check:**
- No lag when selecting marks in playlists with 50+ tracks
- Filtering uses O(n) complexity (not O(n²))
- Computed properties cache properly (verify in DevTools)
</verification>

<success_criteria>
## Measurable Success Criteria

1. **Mark extraction works:**
   - Dropdown shows only marks that exist in current playlist
   - Marks appear in order of first appearance (Map iteration order)
   - Empty/null marks excluded from list

2. **Badge counts accurate:**
   - Each mark displays badge showing track count
   - Counts reflect tracks in current playlist only
   - Badge counts don't change when filters active

3. **Filtering logic correct:**
   - Selecting marks filters track list to show only matching tracks
   - Multiple marks use OR logic (show tracks matching ANY mark)
   - No marks selected → all tracks shown
   - Filtered list updates reactively on mark selection changes

4. **Lifecycle management:**
   - Filter state clears when switching playlists
   - Component unmount clears local state automatically
   - No memory leaks or stale state

5. **Performance:**
   - Filtering uses O(n) complexity with Set.has()
   - No lag when selecting marks in large playlists (50+ tracks)
   - Computed properties cache properly

**Phase 2 is complete when:**
- All 9 manual testing checklist items verified ✓
- Code verification confirms implementation correctness
- Performance check passes (no lag, correct complexity)
- Ready for Phase 3 integration
</success_criteria>

<output>
After completion, create `.planning/phases/02-filter-logic-core/02-01-SUMMARY.md`
</output>
